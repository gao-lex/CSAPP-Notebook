<!-- TOC -->

- [程序的机器级表示](#程序的机器级表示)
    - [1 历史观点](#1-历史观点)
    - [2 程序编码](#2-程序编码)
    - [2.1 机器级代码](#21-机器级代码)
    - [2.2 代码示例](#22-代码示例)
    - [2.3 关于格式的注解](#23-关于格式的注解)
        - [ATT与Intel汇编代码格式](#att与intel汇编代码格式)
        - [把C程序和汇编代码结合起来](#把c程序和汇编代码结合起来)
    - [3 数据格式](#3-数据格式)
    - [4 访问信息](#4-访问信息)

<!-- /TOC -->

# 程序的机器级表示

计算机执行**机器代码**，用字节序列编码低级的操作，包括处理数据，管理内存，读写存储设备上的数据，以及利用网络通信。

**编译器**基于**编程语言的规则**，**目标机器的指令集**和**操作系统遵循的惯例**，经过一系列的阶段生成**机器代码**。

`GCC C`语言编译器以**汇编代码**的形式产生输出，**汇编代码是机器代码的文本表示**，给出程序中的每一条指令。

`GCC`调用**汇编器**和**链接器**，根据**汇编代码**生成可执行的**机器代码**。

## 1 历史观点

`Intel`处理器系列俗称`x86`，1978 年，`Intel` 发布了第一款 `x86` 指令集的微处理器——`Intel 8086`。而后每个后继处理器的设计都是**后向兼容的--较早版本上变异的代码可在较新的处理器上运行**。

> IA32:Intel 32位体系结构(Intel Architecture 32-bit)。

> Intel64:IA32的64位拓展，也称为x86-64
d
> x86:代指整个系列

## 2 程序编码

一个C程序，有两个文件`p1.c`和`p2.c`，编译代码:

```bash
linux> gcc -Og -o p p1.c p2.c
# 编译选项-Og优化等级可生成符合原始C代码整体结构的机器代码
# 旧版本GCC可以用-O1
```

|**将源代码转化成可执行代码的过程**|
|:---:|
|**C预处理器**拓展源代码<br>插入用`#include`指定的文件<br>拓展用`#define`指定的宏<br>⬇|
|**编译器**产生两个源文件的**汇编代码**`p1.s`和`p2.s`<br>⬇|
|**汇编器**将汇编代码转化为二进制**目标代码文件**`p1.o`和`p2.o`<br>**目标代码**是**机器代码**的一种形式，它包含所有指令的二进制表示，但还没有填入全局的地址<br>⬇|
|**链接器**将两个目标代码文件与实现库函数的代码合并，产生最终的**可执行代码文件**`p`|

## 2.1 机器级代码

计算机使用更简单的**抽象**模型来隐藏实现的细节

|最重要的两种抽象|
|:---|
|1. **`ISA`(指令集体系结构或指令集架构)**:定义机器级程序的格式和行为，定义了处理器状态，指令的格式，以及每条指令对状态的影响。|
|2. 机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。|

`x86-64`的机器代码和原始的`C`代码差别非常大，一些对`C`语言程序员隐藏的处理器状态都是可见的:

|寄存器|功能|
|:---:|:---|
|**程序计数器(`PC`)**|给出将要执行的吓一条指令在内存中的地址|
|**整数寄存器**|包含16个命名的位置，分别存储64位的值。|
|**条件码寄存器**|保存最近执行的算术或逻辑指令的状态信息。|
|**浮点寄存器**|存放浮点数据|

## 2.2 代码示例

```c
//mstore.c
long mult2(long,long);
void multstore(long x,long y,long *dest){
    long t = mult2(x,y);
    *dest = t;
}
```

```bash
# 产生汇编文件mstore.s
linux> gcc -0g -S mstore.c
# 产生目标代码文件mstore.o
linux> gcc -Og -c mstore.c
# 反汇编器，根据机器代码文件善生类似于汇编代码的格式
linux> objdump -d mstore.o
```

|机器代码和反汇编特性|
|:---|
|1. `x86-64`的**指令长度**从`1-15`字节不等|
|2. **设计指令格式的方式**是:从某个给定的位置开始，可以将字节惟一地解码成机器指令。eg:只有指令`pushq %rbx`以字节值`53`开头|
|3. 反汇编器只是基于机器代码文件中的字节序列来确定汇编代码，它不需要源代码或汇编代码。|
|4. 反汇编器使用的指令**命名规则**与GCC生成的汇编代码使用的有细微差别。|

**生成实际可执行的代码需要对一组目标代码通过链接器连接，而这一组目标代码文件中必须含有一个`main`函数。**

## 2.3 关于格式的注解

```asm
;mstore.s
	.file	"mstore.c"
	.text
	.globl	multstore
	.type	multstore, @function
multstore:
.LFB0:
	.cfi_startproc
	pushq	%rbx
	.cfi_def_cfa_offset 16
	.cfi_offset 3, -16
	movq	%rdx, %rbx
	call	mult2@PLT
	movq	%rax, (%rbx)
	popq	%rbx
	.cfi_def_cfa_offset 8
	ret
	.cfi_endproc
.LFE0:
	.size	multstore, .-multstore
	.ident	"GCC: (Ubuntu 7.3.0-16ubuntu3) 7.3.0"
	.section	.note.GNU-stack,"",@progbits

```

所有以`.`开头的行都是知道汇编器和链接器工作的伪指令。

### ATT与Intel汇编代码格式

`ATT`是`GCC`，`OBJDUMP`和其他一些工具的默认格式。

```bash
# 产生Intel格式的汇编代码
linux> gcc -Og -S -masm=intel mstore.c
```

|**Intel和ATT格式的不同**|
|:---|
|1. Intel省略了指示大小的后缀。|
|2. Intel省略了寄存器名字前面的`%`符号|
|3. Intel用不同的方式来描述内存中的位置。eg:`QWORD PTR [rbx]`而不是'(%rbx)'|
|4. 在带有多个操作数的指令下，两组格式列出操作数的顺序相反|

### 把C程序和汇编代码结合起来

虽然`C`编译器在把程序中的计算转换到机器代码方面十分出色，但是仍然有一些机器特性是`C`程序访问不到的。eg:`x86-64`执行算术或逻辑运算时，如果得到的运算结果的低`8`位有偶数个`1`，则`PF`(奇偶标志`parity falg`)条件码标志设置为`1`，否则为`0`。在C语言中计算这个信息需要至少`7`次移位，掩码和异或运算。在程序在插入几条汇编代码指令就能很容易完成这项任务。

|在C程序中插入汇编代码的方法有|
|:---|
|1. 编写完整的函数，放进独立的汇编代码文件中，让汇编器和链接器将其和`C`语言代码结合起来。|
|2. 使用`GCC`的内联汇编(`inline assembly`)特性，用`asm`伪指令可以在`C`程序中包含简短的汇编代码。|

在C程序中包含汇编代码使这些代码与某类特殊的机器相关。

## 3 数据格式

由于是由16位体系结构拓展成32位的。Intel用**word表示16位**数据类型。**double words表示32位**数，**quad words表示64位**数。

## 4 访问信息

![](./image/整数寄存器.jpg)

生成1字节和2字节数字和指令会保持
