<!-- TOC -->

- [程序的机器级表示](#程序的机器级表示)
    - [1 历史观点](#1-历史观点)
    - [2 程序编码](#2-程序编码)
    - [2.1 机器级代码](#21-机器级代码)
    - [2.2 代码示例](#22-代码示例)
    - [2.3 关于格式的注解](#23-关于格式的注解)
        - [ATT与Intel汇编代码格式](#att与intel汇编代码格式)
        - [把C程序和汇编代码结合起来](#把c程序和汇编代码结合起来)
    - [3 数据格式](#3-数据格式)
    - [4 访问信息](#4-访问信息)
        - [4.1 操作数指示符](#41-操作数指示符)
        - [4.2 数据传送指令](#42-数据传送指令)
        - [4.3 数据传送示例](#43-数据传送示例)
        - [4.4 压入和弹出栈数据](#44-压入和弹出栈数据)
    - [5 算术和逻辑操作](#5-算术和逻辑操作)
        - [5.1 加载有效地址](#51-加载有效地址)
        - [5.2 一元和二元操作](#52-一元和二元操作)
        - [5.3 移位操作](#53-移位操作)
        - [5.4 讨论](#54-讨论)
        - [5.5 特殊的算术操作](#55-特殊的算术操作)
    - [6 控制](#6-控制)
        - [6.1 条件码](#61-条件码)
            - [比较和测试指令](#比较和测试指令)
        - [6.2 访问条件码](#62-访问条件码)
            - [SET指令](#set指令)
        - [6.3 跳转指令](#63-跳转指令)
        - [6.4 跳转指令的编码](#64-跳转指令的编码)
        - [6.5 用条件控制来实现条件分支](#65-用条件控制来实现条件分支)
        - [6.6 用条件传送来实现条件分支](#66-用条件传送来实现条件分支)
        - [6.7 循环](#67-循环)
            - [do-while循环](#do-while循环)
            - [while循环](#while循环)
            - [for循环](#for循环)
        - [6.8 switch语句](#68-switch语句)
    - [7 过程](#7-过程)
        - [7.1 运行时栈](#71-运行时栈)
        - [7.2 转移控制](#72-转移控制)
        - [7.3 数据传送](#73-数据传送)
        - [7.4 栈上的局部存储](#74-栈上的局部存储)
        - [7.5 寄存器中的局部存储空间](#75-寄存器中的局部存储空间)
        - [7.6 递归过程](#76-递归过程)
    - [8 数组分配和访问](#8-数组分配和访问)
        - [8.1 基本原则](#81-基本原则)
        - [8.2 指针运算](#82-指针运算)
        - [8.3 嵌套的数组](#83-嵌套的数组)
        - [8.4 定长数组](#84-定长数组)
        - [8.5 变长数组](#85-变长数组)
    - [9 异质的数据结构](#9-异质的数据结构)
        - [9.1 结构](#91-结构)
        - [9.2 联合](#92-联合)
        - [9.3 数据对齐](#93-数据对齐)
    - [10 在机器级程序中将控制与数据结合起来](#10-在机器级程序中将控制与数据结合起来)
        - [10.1 理解指针](#101-理解指针)
        - [10.2 应用：使用GDB调试器](#102-应用使用gdb调试器)
        - [10.3 内存越界引用和缓冲区溢出](#103-内存越界引用和缓冲区溢出)
        - [10.4 对抗缓冲区溢出攻击](#104-对抗缓冲区溢出攻击)
        - [10.5 支持变长栈帧](#105-支持变长栈帧)
    - [11 浮点代码](#11-浮点代码)
        - [11.1 浮点传送和转换操作](#111-浮点传送和转换操作)
        - [11.2 过程中的浮点代码](#112-过程中的浮点代码)
        - [11.3 浮点运算和操作](#113-浮点运算和操作)
        - [11.4 定义和使用浮点常数](#114-定义和使用浮点常数)
        - [11.5 在浮点代码中使用位级操作](#115-在浮点代码中使用位级操作)
        - [11.6 浮点比较操作](#116-浮点比较操作)
        - [11.7 对浮点代码的观察结论](#117-对浮点代码的观察结论)

<!-- /TOC -->

# 程序的机器级表示

计算机执行 **机器代码** ，用字节序列编码低级的操作，包括处理数据，管理内存，读写存储设备上的数据，以及利用网络通信。

**编译器**基于 **编程语言的规则** ， **目标机器的指令集** 和 **操作系统遵循的惯例** ，经过一系列的阶段生成 **机器代码** 。

`GCC C` 语言编译器以 **汇编代码** 的形式产生输出， **汇编代码是机器代码的文本表示** ，给出程序中的每一条指令。

`GCC`调用 **汇编器** 和 **链接器** ，根据 **汇编代码** 生成可执行的 **机器代码** 。

---

## 1 历史观点

`Intel` 处理器系列俗称 `x86`  ，1978 年， `Intel`  发布了第一款  `x86`  指令集的微处理器—— `Intel 8086` 。而后每个后继处理器的设计都是**后向兼容的--较早版本上变异的代码可在较新的处理器上运行**。

> **IA32** :Intel 32位体系结构(Intel Architecture 32-bit)。

> **Intel64** :IA32的64位拓展，也称为x86-64

> **x86** :代指整个系列

---

## 2 程序编码

一个C程序，有两个文件 `p1.c` 和 `p2.c` ，编译代码:

```bash
linux> gcc -Og -o p p1.c p2.c
# 编译选项-Og优化等级可生成符合原始C代码整体结构的机器代码
# 旧版本GCC可以用-O1
```

|**将源代码转化成可执行代码的过程**|
|:---:|
|**C预处理器** 拓展源代码<br>插入用 `#include` 指定的文件<br>拓展用 `#define` 指定的宏<br>⬇|
|**编译器** 产生两个源文件的 **汇编代码** `p1.s` 和 `p2.s` <br>⬇|
|**汇编器** 将汇编代码转化为二进制 **目标代码文件** `p1.o` 和 `p2.o` <br> **目标代码** 是 **机器代码** 的一种形式，它包含所有指令的二进制表示，但还没有填入全局的地址<br>⬇|
|**链接器** 将两个目标代码文件与实现库函数的代码合并，产生最终的 **可执行代码文件** `p`|

---

## 2.1 机器级代码

计算机使用更简单的 **抽象** 模型来隐藏实现的细节

|最重要的两种抽象|
|:---|
|1. **`ISA`(指令集体系结构或指令集架构)** :定义机器级程序的格式和行为，定义了处理器状态，指令的格式，以及每条指令对状态的影响。|
|2. 机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。|

`x86-64` 的机器代码和原始的 `C` 代码差别非常大，一些对 `C` 语言程序员隐藏的处理器状态都是可见的:

|寄存器|功能|
|:---:|:---|
|**程序计数器(`PC`)**|给出将要执行的吓一条指令在内存中的地址|
|**整数寄存器**|包含16个命名的位置，分别存储64位的值。|
|**条件码寄存器**|保存最近执行的算术或逻辑指令的状态信息。|
|**浮点寄存器**|存放浮点数据|

---

## 2.2 代码示例

```c
//mstore.c
long mult2(long,long);
void multstore(long x,long y,long *dest){
    long t = mult2(x,y);
    *dest = t;
}
```

```bash
# 产生汇编文件mstore.s
linux> gcc -0g -S mstore.c
# 产生目标代码文件mstore.o
linux> gcc -Og -c mstore.c
# 反汇编器，根据机器代码文件善生类似于汇编代码的格式
linux> objdump -d mstore.o
```

|机器代码和反汇编特性|
|:---|
|1. `x86-64` 的 **指令长度** 从 `1-15` 字节不等|
|2. **设计指令格式的方式** 是:从某个给定的位置开始，可以将字节惟一地解码成机器指令。eg:只有指令 `pushq %rbx` 以字节值 `53` 开头|
|3. 反汇编器只是基于机器代码文件中的字节序列来确定汇编代码，它不需要源代码或汇编代码。|
|4. 反汇编器使用的指令 **命名规则** 与GCC生成的汇编代码使用的有细微差别。|

**生成实际可执行的代码需要对一组目标代码通过链接器连接，而这一组目标代码文件中必须含有一个`main`函数。**

---

## 2.3 关于格式的注解

```asm
;mstore.s
	.file	"mstore.c"
	.text
	.globl	multstore
	.type	multstore, @function
multstore:
.LFB0:
	.cfi_startproc
	pushq	%rbx
	.cfi_def_cfa_offset 16
	.cfi_offset 3, -16
	movq	%rdx, %rbx
	call	mult2@PLT
	movq	%rax, (%rbx)
	popq	%rbx
	.cfi_def_cfa_offset 8
	ret
	.cfi_endproc
.LFE0:
	.size	multstore, .-multstore
	.ident	"GCC: (Ubuntu 7.3.0-16ubuntu3) 7.3.0"
	.section	.note.GNU-stack,"",@progbits

```

所有以 `.` 开头的行都是知道汇编器和链接器工作的伪指令。

---

### ATT与Intel汇编代码格式

`ATT` 是 `GCC` ， `OBJDUMP` 和其他一些工具的默认格式。

```bash
# 产生Intel格式的汇编代码
linux> gcc -Og -S -masm=intel mstore.c
```

|**Intel和ATT格式的不同**|
|:---|
|1. Intel省略了指示大小的后缀。|
|2. Intel省略了寄存器名字前面的 `%` 符号|
|3. Intel用不同的方式来描述内存中的位置。eg:`QWORD PTR [rbx]`而不是 `(%rbx)` |
|4. 在带有多个操作数的指令下，两组格式列出操作数的顺序相反|

---

### 把C程序和汇编代码结合起来

虽然 `C` 编译器在把程序中的计算转换到机器代码方面十分出色，但是仍然有一些机器特性是 `C` 程序访问不到的。eg: `x86-64` 执行算术或逻辑运算时，如果得到的运算结果的低 `8` 位有偶数个 `1` ，则 `PF` (奇偶标志 `parity falg` )条件码标志设置为 `1` ，否则为 `0` 。在C语言中计算这个信息需要至少 `7` 次移位，掩码和异或运算。在程序在插入几条汇编代码指令就能很容易完成这项任务。

|在C程序中插入汇编代码的方法有|
|:---|
|1. 编写完整的函数，放进独立的汇编代码文件中，让汇编器和链接器将其和 `C` 语言代码结合起来。|
|2. 使用 `GCC` 的内联汇编( `inline assembly` )特性，用 `asm` 伪指令可以在 `C` 程序中包含简短的汇编代码。|

在C程序中包含汇编代码使这些代码与某类特殊的机器相关。

---

## 3 数据格式

由于是由16位体系结构拓展成32位的。Intel用 **word表示16位** 数据类型。 **double words表示32位** 数， **quad words表示64位** 数。

---

## 4 访问信息

![](./image/整数寄存器.jpg)

生成1字节和2字节数字和指令会保持剩下的字节不变；生成4字节数字的指令会把高位4个字节置为0.

---

### 4.1 操作数指示符

![](./image/操作数格式.png)
比例因子s必须是1、2、3或者8

---

### 4.2 数据传送指令

![](./image/简单的数据传送指令.png)

**源操作数** 指定的值是一个立即数，存储在寄存器或内存中。 **目的操作数** 指定一个位置，是一个寄存器或地址。 **传送指令的两个操作数不能都指向从内存地址** 。

传送指令的两个操作数不能都指向内存地址。大多数情况中， `mov` 指令只会更新目的操作数指定的那些寄存器字节或内存为止，但 `movl` 指令以寄存器作为目的时，会把该寄存器的高4位字节设置为0。

常规的 `movq` 指令只能以表示为 **32位补码** 数字的立即数作为源操作数，然后把这个值 **符号拓展** 得到64位的值，放到目的位置。而 `movabsq` 指令能够以任意64位立即数作为源操作数，并且只能以寄存器作为目的。

`movz` 和 `movs` 数据移动指令在将较小的源复制到较大的目的时使用。这些指令把数据从源复制到目的寄存器。

![](./image/movz.png)

**没有把4字节源零拓展到8字节目的的指令** 。这样的数据传送可以用 `movl` 指令来实现。

![](./image/movs.png)

`cltq` 指令(等同于 `movslq %eax,%rax` )没有操作数，它总是以寄存器 `%eax` 作为源， `%rax` 作为符号拓展结果的目的。

```asm
movabsq $0x0011223344556677,%rax	;%rax = 0011223344556677
movb $-1,%al						;%rax = 00112233445566FF
movw $-1,%ax						;%rax = 001122334455FFFF
movl $-1,%eax						;%rax = 00000000FFFFFFFF
mov $-1,%rax						;%rax = FFFFFFFFFFFFFFFF
movabsq $0x0011223344556677,%rax	;%rax = 0011223344556677
movb $0xAA,%dl						;%dl  = AA
movb %dl,%al						;%rax = 00112233445566AA
movsbq %dl,%rax						;%rax = FFFFFFFFFFFFFFAA
movzbq %dl,%rax						;%rax = 00000000000000AA
```

---

### 4.3 数据传送示例

```c
//exchange.c
long exchange(long *xp,long y)	//exchange:
{					//xp in %rdi,y in %rsi
	long x = *xp;	//movq	(%rdi), %rax
	*xp = y;		//movq	%rsi, (%rdi)
	return x;		//ret
}
```

C语言中所谓的 “指针” 其实就是地址。间接引用指针就是将该指针保存在寄存器中，而不是内存中。访问寄存器比访问内存要快得多。

---

### 4.4 压入和弹出栈数据

在x86-64中，程序栈存放在内存中某个区域。 **栈向下增长** ，栈顶元素的地址是所有栈元素地址中最低的。

![](./image/入栈和出栈指令.png)

将一个四字值压入栈中，首先需要将栈指针减8，然后将值写入新的栈顶地址。所以 `pushq %rbp` = `sub $8,%rsp` 和 `movq %rbq,(%rsp)` 

---

## 5 算术和逻辑操作

![](./image/整数算术操作.png)

只有 `leaq` 指令没有其他大小的变种。 `leaq` 通常用来执行简单的算术操作。这里的 **操作顺序与ATT格式的汇编代码中的相反** 。

---

### 5.1 加载有效地址

![](./image/整数算术操作.png)

**加载有效地址(load effective address)** 指令 `leaq` 实际上是 `movq` 的变形。该指令将有效地址写入到目的操作数，并不是从指定的位置读入数据。 `leap` 指令能执行加法和有限形式的乘法。

```c
long scale(long x,long y,long z){
	long t = x + 4*y + 12*z;
	return t;
}
```

```asm
scale:
	;x in %rdi,y in %rsi,z in %rdx
	leaq	(%rdi,%rsi,4), %rax	;x = x+4*y
	leaq	(%rdx,%rdx,2), %rcx	;temp = z+2*z
	leaq	0(,%rcx,4), %rdx	;z = temp*4
	addq	%rdx, %rax			;x = x+z
	ret
```

---

### 5.2 一元和二元操作


**一元操作** 数可以是一个寄存器，也可以是一个内存位置。eg： `incq (%rsp)` 会让栈顶的8字节元素加一。

**二元操作** ：第二个操作数既是源又是目的。第一个操作数可以是立即数、寄存器或是内存地址。第二个操作数可以是寄存器或是内存地址。 **当第二个操作数为内存地址时，处理器必须从内存读出值，执行操作，再把结果写回。** 

---

### 5.3 移位操作

移位量可以是一个立即数，或者放在单字节寄存器 `%cl` 中。x86-64中，移位操作对 `w` 位长的数据进行操作。 `salb` 看 `cl` 的低  `3`  位数值， `salw` 看 `cl` 的低 `4` 位数值， `sall` 看 `cl` 的低 `5` 位数值， `salq` 看 `cl` 的低 `6` 位数值。

`SAL` 和 `SHL` 左移，在右边补0； `SAR` 算术移位（填上符号位）， `SHR` 逻辑移位（填上0）.

---

### 5.4 讨论

大多数指令，即可用于无符号运算，也可用于补码运算。只有右移操作区分有符号和无符号数。这使得补码运算成为实现有符号整数运算的一种较好的方法。

---

### 5.5 特殊的算术操作

两个 `64` 位有符号或无符号整数相乘得到的乘积需要 `128` 位来表示。 `x86-64` 指令集对 `128` 位( `16` 字节)数的操作提供有限的支持。延续字(`2`字节)、双字( `4` 字节)和四字( `8` 字节)的命名管理，Intel把 `16` 字节的数称为 `8` 字( `oct word` )。

![](./image/特殊的算术操作.png)

`imulq` 指令有两种不同的形式。其中一种，是 `IMUL` 指令类中的一种。这种形式的 `imulq` 指令是一个 “双操作数” 乘法指令。它从两个 `64` 位操作数产生一个 `64` 位乘积。

```c
//store_uprod.c
#include <inttypes.h>

typedef unsigned __int128 uint128_t;

void store_uprod(uint128_t *dest,uint64_t x,uint64_t y){
	*dest = x*(uint128_t) y;
}
```

`__int128` 是 `GCC` 提供的 `128` 位整数支持。我们用 `typedef` 沿用 `inttypes.h` 的命名规律。

```asm
;store_uprod.s
;dest in %rdi, x in %rsi, y in %rdx
store_uprod:
	movq	%rsi, %rax
	mulq	%rdx
	movq	%rax, (%rdi)
	movq	%rdx, 8(%rdi)
	ret
```

---

## 6 控制

`C` 语言中的语句和机器代码中的指令都是按照它们在程序中出现的次序来顺序执行。用 `jump` 指令可以改变一组机器指令的执行顺序， `jump` 指令指定控制应该被传递到程序的某个其他部分，可能是依赖于某个测试结果。

---

### 6.1 条件码

除了 整数寄存器 ，CPU还维护着一组单个位的 **条件码** (condition code) 寄存器。它们 **描述了最近的算术或逻辑操作的属性** 。可以检测这些寄存器来执行条件分支指令。最常用的条件码有：

|条件码|名称|作用|
|:---:|:---:|:---|
|CF|进位标志|最近的操作使最高位产生了进位。可用来检测无符号操作的溢出|
|ZF|零标志|最近的操作得出的结果为0|
|SF|符号标志|最近的操作得到的结果为负数|
|OF|溢出标志|最近的操作导致一个补码溢出——正溢出或负溢出|

`leaq` 指令不会改变任何条件码，因为它是用来进行地址计算的。除此之外，所有算术和逻辑操作都会设置条件码。对于 **移位操作** ，进位标志将设置为最后一个被移出的位，溢出标志设置为0。 `INC` 和 `DEC` 会设置 溢出 和 零标志 ，但不会改变 进位标志 。

#### 比较和测试指令

![](./image/比较和测试指令.png)

比较和测试指令 只设置 条件码 而不改变任何其他寄存器。 `CMP` 和 `SUB` 指令一样， `TEST` 和 `ADD` 指令一样，除了它们置设置条件码而不改变目的寄存器的值。

---

### 6.2 访问条件码

条件码通常不会直接读取，常用的使用方法有三种：

1. 根据条件码的某种组合，将一个字节设置为0或者1：指令 `set` 
2. 可以条件跳转到程序的某个其他部分
3. 可以有条件地传送数据

#### SET指令
![](./image/SET指令.png)

`SET` 指令的目的操作数是 **低位单字节** 寄存器元素之一，或者是一个字节的内存位置。为了得到 `32` 位或 `64` 位的结果，必须对 **高位清零** 。

计算 `C` 语言表达式 `a<b` 的典型指令:

```asm
;int comp(data_t a,data_t b)
;a in %rdi , b in %rsi
comp:
    cmpq %rsi,%rdi  ;虽然参数列出的顺序是 %rsi , %rdi ，实际比较的是 a 和 b
    setl %al
    movzbl %al,%eax ;movzbl会使%rax的高四字节清零
    ret
```

某些底层的机器指令可能有多个名字，我们称之为 **同义名(synonym)** 。eg：setg(设置大于)和setnle(设置不小于等于)指的就是同一条机器指令。编译器和反汇编器会随意决定使用哪个名字。

**无符号比较** 使用的是 进位标志CF 和 零标志ZF 的组合

**有符号比较** 使用是 `SF^OF` 和 `ZF` 的其他组合：当 `OF=1` 时，当且仅当 `SF=0` 时有   `a<b`


---

### 6.3 跳转指令

**跳转指令** 导致执行切换到程序中一个全新的位置。在汇编代码中，这些跳转的目的地通常用一个 标号(label) 指明。



---

### 6.4 跳转指令的编码

---

### 6.5 用条件控制来实现条件分支

---

### 6.6 用条件传送来实现条件分支

---

### 6.7 循环

#### do-while循环


#### while循环


#### for循环



---

### 6.8 switch语句

---


## 7 过程

### 7.1 运行时栈


### 7.2 转移控制


### 7.3 数据传送


### 7.4 栈上的局部存储


### 7.5 寄存器中的局部存储空间


### 7.6 递归过程

## 8 数组分配和访问

### 8.1 基本原则

### 8.2 指针运算

### 8.3 嵌套的数组

### 8.4 定长数组

### 8.5 变长数组

## 9 异质的数据结构

### 9.1 结构

### 9.2 联合

### 9.3 数据对齐

## 10 在机器级程序中将控制与数据结合起来

### 10.1 理解指针

### 10.2 应用：使用GDB调试器

### 10.3 内存越界引用和缓冲区溢出

### 10.4 对抗缓冲区溢出攻击

### 10.5 支持变长栈帧

## 11 浮点代码

### 11.1 浮点传送和转换操作

### 11.2 过程中的浮点代码

### 11.3 浮点运算和操作

### 11.4 定义和使用浮点常数

### 11.5 在浮点代码中使用位级操作

### 11.6 浮点比较操作

### 11.7 对浮点代码的观察结论

