<!-- TOC -->

- [信息的处理和表示](#信息的处理和表示)
    - [1 信息存储](#1-信息存储)
    - [2 整数表示](#2-整数表示)
        - [练习题25](#练习题25)
        - [练习题26](#练习题26)
    - [3 整数运算](#3-整数运算)
        - [练习题32](#练习题32)
        - [总结](#总结)
    - [4 浮点数](#4-浮点数)

<!-- /TOC -->

# 信息的处理和表示

**无符号数编码**基于传统的二进制表示法。**补码(two's-complement)编码**表示有符号整数的最常见的方式。**浮点数(floating-point)编码**是表示实数的科学计数法的以2为基数的版本。

---

计算机用有限数量的位来对应一个数字编码，当结果太大以至于不能表示时，某些运算就会**溢出**。

---

整数运算一组正数的运算可能会产生一个负的结果。

---

浮点运算有完全不同的数学属性，虽然溢出会产生特殊的值`+无穷`，但一组正数的乘积总是正的。由于表示的精度有限，浮点运算不可结合。eg：`(3,14+1e20)-1e20`的值为`0`，而`3.14+(1e20-1e20)`的值为`3.14`。

---

整数是精确表示，只能编码一个相对较小的数值范围；浮点数是近似表示，表示范围大。

---

## 1 信息存储

计算机使用**8**位的块，称为**字节(byte)**,作为最小的可寻址的内存单位，而不是访问内存中单独的位。机器级程序将内存视为一个非常大的字节数组，称为**虚拟内存**。

---

**字长(word size)**，指明指针数据的标称大小，字长决定最重要的系统参数就是**虚拟地址空间的最大大小**。

---

**异或**`(Exclusive-Or[Xor])`：`A=1 或 B=1 `时，`A^B = 1`；`A=1 且 B=1 `时，`A^B = 0`

---

## 2 整数表示

|编码|特性|
|:---:|:---|
|原码|原码就是二进制定点表示法，即最高位为符号位，“0”表示正，“1”表示负，其余位表示数值的大小|
|反码|原码就是二进制定点表示法，即最高位为符号位，“0”表示正，“1”表示负，其余位表示数值的大小。|
|补码|正数的补码与其原码相同；负数的补码是在其反码的末位加1|

---

> **补码(Two's complement)**和**反码(Ones' complement)**中**撇号的位置不同**。术语补码来源于对于非负数`x`，我们用`2^w-x`(这里只有一个2)来表示`-x`的`w`位表示。术语反码表示我们用`[111...1]-x`(这里有很多个1)来计算`-x`的反码表示。

---

对于C语言的实现来说，处理同样字长的有符号数和无符号数之间相互转换的一般规则是：数值可能会改变，但是位模式不变。

---

要将一个无符号数转换为一个更大的数据类型，需要在开头添加零，这叫做**零拓展(zero extension)**。

要将一个补码数字转换为一个更大的数据类型，需要在开头添加最高有效位的值，这叫做**符号拓展(sign extension)**。

---

将一个`w`位的数截断为一个`k`位的数字时，我们丢弃高`w-k`位。

`x`是原数，`x'`是将其截断为k位的结果。`x'`为无符号数时，`x'=x mod x^k`。`x'`为补码表示时，将无符号`x'`转成补码表示即可。

---

### 练习题25

当参数`length`等于`0`时，这段代码会`Segmentation fault (core dumped)`:

```c
float sum_elements(float a[],unsigned length){
    int i;
    float result = 0;

    for(i=0;i<=length-1;i++)
        result+=a[i];
    return result;
}
```

答：参数`ength`是无符号的，计算`0-1`将进行无符号运算，这将得到UMAX，所有int都小于等于UMAX，所以这个条件恒为真，内存访问越界。

修正办法：

* plan1：`length`声明为`int`；
* plan2：`for`的测试条件改为`i<length`

---

### 练习题26

用字符串库函数`strlen()`判断一个字符串是否比另一个字符串更长。

```c
size_t strlen(const char* s);

int strlonger(char *s,char*t){
    return (strlen(s)-strlen(t)) > 0;
}

```

错误：当`s`比`t`短时，因为无符号-无符号还是无符号，实际为负，但是变成了一个很大的无符号数，且大于0；返回1；

修改：`return strlen(s)>strlen(t)`

---

## 3 整数运算

|运算|计算|溢出检测|
|:---:|:---|:---|
|无符号加法|`0<=x,y<=Umax`<br>![](./image/无符号加法.png)|溢出后`s<min(x,y)`|
|补码加法|`-2^(w-1)<=x,y<{2^(w-1)-1}`<br>![](./image/补码加法.png)|当`x,y>0`且`x+y<0`时发生了**正溢出**<br>当`x,y<0`且`x+y>0`时发生了**负溢出**|


### 练习题32

如果`x-y`不产生溢出，函数就返回`1`。

```c
int tsub_ok(int x,int y){
    return tadd_ok(x,-y); 
}

```

当`y`取`Tmin`时，`-y`也等于`Tmin`。因此函数`tadd_ok`会认为只要`x`是负数，就会溢出，而`x`为非负数，不会溢出。实际上：`x`为负数时，`tsub_ok(x,TMin)`为1，而`x`为非负时，它为`0`。

---

> 求补码的非：1.按位取反再加一；2.将最右边的1的左边的所有位取反

---

|运算|计算|
|:---:|:---|
|无符号乘法|`x*y = (x*y) mod 2^w`|
|补码乘法|上式转补码|
|整数乘法、除法|用移位实现|

---

### 总结

计算机执行的“整数”运算实际上是一种模运算。表示数字的有限字长限制了可能的值的取值范围，运算结果可能溢出。

---

补码提供了一种既能表示正数也能表示负数的灵活方法，同时使用了与执行无符号算术相应的位级实现，加减乘数，无论运算数是无符号还是补码，都有完全一样或非常类似的位级行为。

---



## 4 浮点数

![](./image/IEEE浮点标准.png)

![](./image/IEEE浮点表示.jpg)

根据exp的值，被编码的值可以分成三种不同的情况：

![](./image/单精度浮点数值的分类.png)